Linuxの仕組み

プロセス
	起動してから稼働中
	経過時間
		プロセスが開始してから終了するまでの経過時間
	使用時間	
		プロセスが実際に論理CPUを使用した時間

プロセススケジューラ（スケジューラ）
	１つの論理CPU上で同時に動かせるプロセスは一つだけ
	実行可能な複数のプロセスにタイムスライスという単位で、順番にCPUを使わせる

	タイムスライス
		sysctlのkernel.sched_latency_nsパラメータ(ナノ秒単位の時間)の期間を基準に設定。つまりこの秒数区切りでプロセス毎にcpuの使用が割り当てられる
		ある論理CPUに対して複数のプロセスが動いてる場合、タイムスライスは、kernel.sched_latency_ns/プロセス数 になる。こうすることでプロセス数が増えたときになかなかcpu使用時間が割り当てられないような問題を避けれる。
		また、nice値と呼ばれる値を用いることで、プロセス毎に割り当てるタイムスライスの値を増減できる。

コンテキストスイッチ
	論理CPU上で動作するプロセスが切り替わること
	プロセスがどんなコードを実行していても、タイムスライスが切れると容赦なく発生する。

性能要件の指標

	ターンアラウンドタイム
		システムに処理を依頼してから、個々の処理が終わるまでの時間
	スループット
		単位時間あたりに処理を終えられる数
		

カーネルモード
	CPUにあたえられるモードの１つで制約なくデバイスのリソース、たとえばストレージ	に対してアクセスできるモード
ユーザーモード
	CPUに与えられるモードの１つで、特定の命令を実行できない。
カーネル
	カーネルモードで動作するデバイスへのアクセス権限を持ったプロセス

システムコール
	プロセスがカーネルに処理を依頼する方法
	システムコールが行われるとCPUの動作がプロセスからカーネルに遷移し、カーネルに定められた処理を実行する	
	どのプログラミング言語でもシステムコールを発行する

	通常の関数呼び出しと違って、c言語などの高級言語からは呼び出せず、アーキテクチャ依存のアセンブリコードを使って呼び出す必要がある。
		高級言語ごとに、システムコールのラッパー関数が用意されており、各高級言語を利用する際はラッパー関数を叩くことでシステムコールを発行することができる。
			例えばC言語だと標準ライブラリのlibcがラッパー関数を提供している。

静的ライブラリと共有ライブラリ
	
	前提
		プログラムのコンパイル時に、ソースコードをコンパイルしてオブジェクトファイルを作る
		オブジェクトファイルにライブラリをリンクして実行ファイルを作る

	静的ライブラリ
		リンク時にライブラリ内の関数をプログラムに組み込む
	共有ライブラリ
		リンク時にライブラリ内の呼び出す関数情報のみを実行ファイルに埋め込む
		プログラムの起動時、実行中にライブラリをメモリにロードして、プログラムはその関数を呼び出す

	差異
		静的ライブラリはプログラムサイズが大きく、共有ライブラリはプログラムサイズが小さくなる
		静的ライブラリはライブラリをリンクしないが、共有ライブラリは呼び出す関数に応じたライブラリをリンクする必要がある
		共有ライブラリはリンクしたライブラリが削除されると実行できなくなる。
		ライブラリに問題があった場合、共有ライブラリなら、リンクしてるライブラリを修正するだけで対応が可能。静的ライブラリの場合実行ファイルを作り直す必要がある。

	メモ
		昨今は、共有ライブラリが使われてきたが、Go言語は静的リンクしてる。

シグナル
	あるプロセスが他のプロセスに何かを通知して、外部から実行の流れを強制的に変えるための仕組み
		sigint
			最たる例はSIGINT,ctrl-cで実行できてプロセスを強制終了するやつ
			sigintはkill -INT <pid>で送れるっぽい

		sigstop
			ctrl-z

		sigkill
			このシグナルを受け取ったプロセスは強制終了させられる。sigintで止まらないプロセスに使える
	
		シグナルハンドラ
			プロセスに設定できる項目で、プロセスが実行中にシグナルを受け取った時の振る舞いのことで、プロセス毎に各シグナルに対して登録できる
			シグナルを受信すると実行中の処理を中断してシグナルハンドラを実行して、終わったら元の処理に戻る
			シグナルを無視する設定もできる
			
ジョブ
	シェルがバックグラウンドで実行したプロセスを制御するための仕組み

セッション
	gtermのような端末エミュレータ、sshを通してシステムにログインした時のログインセッションに対応するためのもの
	全てのセッションには端末が紐づいていてそれにより制御する
		ここでいう端末とは、白黒でコマンド打って制御する画面のこと
	pty/<n>という名前の仮想端末がそれぞれのセッションに割り当てられる

	セッションにはセッションIDが割り振られている(SID)
	セッションにはセッションリーダーというプロセスが一つ存在する。通常はbashなどのシェルになる
		セッションリーダのPIDはSIDになる

	セッションに紐づく端末がハングアップ、つまり閉じられると、セッションリーダーにsighupが送られる。bash(セッションリーダー)はこの時自分が管理するジョブを終了させてから、自身を終了させる

プロセスグループ
	複数のプロセスをまとめてコントロールするためのもの
	セッションの中に複数のプロセスグループが存在し、シェルによって作られたジョブと考えればいい。
	プロセスグループを使うことで、プロセスグループに所属する全プロセスに対してシグナルを投げることができる。
	
	フォアグラウンドプロセスグループ
		シェルにおけるフォアグラウンドジョブに対応
		セッションに一つだけ存在し端末に直接アクセスできる

	バックグラウンドプロセスグループ
		シェルにおけるバックグラウンドジョブに対応
		バックグラウンドグループが端末を直接操作しようとすると、SIGSTOPを受けたように操作が一時的に中断され、
		フォアグラウンドプロセスグループになるまで中断状態が続く

デーモン
	常駐プロセス
	他のプロセスなどが終了したときにまとめて消されることがないように以下特徴を持つ。
		端末が割り当てられていない
		独自のセッションを持つ
		initが親



コマンド
	sar コマンド
		cpuが処理している命令の割合を出力するコマンド
		https://qiita.com/maiyama18/items/956ac41c4cf6cf85ae12#cpu	
	strace
		プロセスがどんなシステムコールを発行するか確認できる
	ldd
		プログラムがどのようなライブラリをリンクしているか確認できる
	ps aux
		システムに存在する全プロセスを列挙できる
			プロセスの起動時刻、使った時刻も表示してくれる
	pstree
		プロセスの親子構造を木構造で表示してくれる

	man 7 signal
		シグナルの一覧を見れる
	ps ajx
		セッションについての情報を見れる
		statフィールドに+がついてるものがフォアグラウンドジョブ

	time
		プロセス開始前に使うことで、経過時間と使用時間を計測できる。
		real 経過時間
		user プロセスがユーザランドで動作した使用時間
		sys プロセスによるシステムコール発行の延長で、カーネルが動作していた時の時間